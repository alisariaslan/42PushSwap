==196385== Memcheck, a memory error detector
==196385== Copyright (C) 2002-2017, and GNU GPL'd, by Julian Seward et al.
==196385== Using Valgrind-3.18.1 and LibVEX; rerun with -h for copyright info
==196385== Command: ./a.out 4 67 3 87 23
==196385== Parent PID: 196330
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109FAD: add_last (adder_deller.c:88)
==196385==    by 0x10935D: list_ra (rx.c:25)
==196385==    by 0x10A0A1: sort_phase_one (amel_sort.c:56)
==196385==    by 0x10A0A1: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109F64: add_first (adder_deller.c:69)
==196385==    by 0x1094AC: list_pb (px.c:23)
==196385==    by 0x10A08B: sort_phase_one (amel_sort.c:59)
==196385==    by 0x10A08B: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109E9F: stack_counter (counter.c:51)
==196385==    by 0x10A033: amel_sort (amel_sort.c:72)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x1096FA: shift_min (shifter.c:25)
==196385==    by 0x10A06D: sort_phase_one (amel_sort.c:48)
==196385==    by 0x10A06D: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109E9F: stack_counter (counter.c:51)
==196385==    by 0x10970C: shift_min (shifter.c:35)
==196385==    by 0x10A06D: sort_phase_one (amel_sort.c:48)
==196385==    by 0x10A06D: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109FE2: get_last (adder_deller.c:112)
==196385==    by 0x1093F4: list_rra (rrx.c:23)
==196385==    by 0x10A07B: sort_phase_one (amel_sort.c:51)
==196385==    by 0x10A07B: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109E9F: stack_counter (counter.c:51)
==196385==    by 0x109F03: del_last (adder_deller.c:44)
==196385==    by 0x1093FE: list_rra (rrx.c:24)
==196385==    by 0x10A07B: sort_phase_one (amel_sort.c:51)
==196385==    by 0x10A07B: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109F1B: del_last (adder_deller.c:47)
==196385==    by 0x1093FE: list_rra (rrx.c:24)
==196385==    by 0x10A07B: sort_phase_one (amel_sort.c:51)
==196385==    by 0x10A07B: amel_sort (amel_sort.c:75)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109E9F: stack_counter (counter.c:51)
==196385==    by 0x10A0B0: amel_sort (amel_sort.c:77)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== Conditional jump or move depends on uninitialised value(s)
==196385==    at 0x109EC0: del_first (adder_deller.c:21)
==196385==    by 0x1094E4: list_pa (px.c:36)
==196385==    by 0x10A0C6: sort_phase_two (amel_sort.c:64)
==196385==    by 0x10A0C6: amel_sort (amel_sort.c:80)
==196385==    by 0x10925C: main (push_swap.c:39)
==196385== 
==196385== 
==196385== HEAP SUMMARY:
==196385==     in use at exit: 0 bytes in 0 blocks
==196385==   total heap usage: 15 allocs, 15 frees, 240 bytes allocated
==196385== 
==196385== All heap blocks were freed -- no leaks are possible
==196385== 
==196385== Use --track-origins=yes to see where uninitialised values come from
==196385== For lists of detected and suppressed errors, rerun with: -s
==196385== ERROR SUMMARY: 12 errors from 10 contexts (suppressed: 0 from 0)
